-- The model for typing constraints

module Constraint
  ( Constraint(..)
  , CConstraint(..)
  , Type(..)
  , Var(..)
  , Vars(..)
  , Subst
  , simple
  , implic
  , fn
  , list
  , Sub(..)
  , flattenConstraint
  , partitionConstraint
  , mapConstraint
  , sortConstraint
  )
where

import           Util
import           Data.Name
import qualified Data.Set                      as Set
import           Data.Set                       ( Set
                                                , (\\)
                                                )
import           Data.Map.Strict                ( Map )
import qualified Data.Map.Strict               as Map

-- Simple constraints
-- Created by the user via type annotations
data Constraint = CNil
                | Constraint :^: Constraint
                | Type :~: Type
                deriving (Eq, Show, Ord)

instance Semigroup Constraint where
  CNil      <> c    = c
  c         <> CNil = c
-- Note: this case ensures that <> is associative, but may be inefficient
  (c :^: d) <> e    = c <> (d <> e)
  c         <> d    = c :^: d

instance Monoid Constraint where
  mempty = CNil


flattenConstraint :: Constraint -> [Constraint]
flattenConstraint (c :^: d) = flattenConstraint c <> flattenConstraint d
flattenConstraint c         = [c]

-- Like partition but works on Constraints
partitionConstraint
  :: (Constraint -> Bool) -> Constraint -> (Constraint, Constraint)
partitionConstraint f = bimap mconcat mconcat . partition f . flattenConstraint

-- Like map but for Constraints
mapConstraint :: (Constraint -> b) -> Constraint -> [b]
mapConstraint f = map f . flattenConstraint

sortConstraint :: Constraint -> Constraint
sortConstraint = mconcat . sort . flattenConstraint

-- Computed constraints
-- Generated by the typechecker
data CConstraint = Simple Constraint
                | CConstraint :^^: CConstraint
                -- these are always unification vars
                | E [Var] Constraint CConstraint
                deriving (Eq, Show, Ord)

instance Semigroup CConstraint where
  Simple CNil <> c           = c
  c           <> Simple CNil = c
-- Note: this case ensures that <> is associative, but may be inefficient
  (c :^^: d)  <> e           = c <> (d <> e)
  c           <> d           = c :^^: d

instance Monoid CConstraint where
  mempty = Simple mempty

data Type = TVar Var
          | TCon RawName [Type]
          | TTuple [Type]
          | THole RawName
          | TInt
          | TFloat
          | TString
          deriving (Eq, Show, Ord)

fn :: Type -> Type -> Type
a `fn` b = TCon "->" [a, b]

list :: Type -> Type
list t = TCon "List" [t]

data Var = R RawName
         | U RawName
         deriving (Eq, Show, Ord)

-- The type of substitutions
type Subst = [(Var, Type)]

-- A typeclass for applying substitutions
class Sub a where
  sub :: Subst -> a -> a

instance Sub Type where
  sub s (TVar v   ) = fromMaybe (TVar v) (lookup v s)
  sub s (TCon n ts) = TCon n (map (sub s) ts)
  sub s (TTuple ts) = TTuple (map (sub s) ts)
  sub _ (THole  n ) = THole n
  sub _ TInt        = TInt
  sub _ TFloat      = TFloat
  sub _ TString     = TString

instance Sub Constraint where
  sub _ CNil      = CNil
  sub s (a :^: b) = sub s a :^: sub s b
  sub s (t :~: v) = sub s t :~: sub s v

instance Sub CConstraint where
  sub s (Simple c) = Simple (sub s c)
  sub s (c :^^: d) = sub s c :^^: sub s d
-- not worrying about var capture here because unification vars are unique.
-- this could be problematic, be aware
  sub s (E vs q c) = E vs (sub s q) (sub s c)

-- Vars is defined for any type for which we can extract a set of free
-- unification variables
class Vars a where
  -- Get the free unification variables from `a`
  fuv  :: a -> Set Var

instance Vars Type where
  fuv (TVar (U v)) = Set.singleton (U v)
  fuv (TVar _    ) = mempty
  fuv (TCon _ ts ) = Set.unions (map fuv ts)
  fuv (TTuple ts ) = Set.unions (map fuv ts)
  fuv (THole  _  ) = mempty
  fuv TInt         = mempty
  fuv TFloat       = mempty
  fuv TString      = mempty

instance Vars Constraint where
  fuv CNil      = mempty
  fuv (a :^: b) = fuv a <> fuv b
  fuv (t :~: v) = fuv t <> fuv v

instance Vars CConstraint where
  fuv (Simple c   ) = fuv c
  fuv (a :^^: b   ) = fuv a <> fuv b
  fuv (E vars c cc) = fuv c <> fuv cc \\ Set.fromList vars

instance Vars b => Vars (Map a b) where
  fuv env = Set.unions (map fuv (Map.elems env))

simple :: CConstraint -> Constraint
simple E{}        = mempty
simple (Simple c) = c
simple (c :^^: d) = simple c <> simple d

implic :: CConstraint -> [(Set Var, Constraint, CConstraint)]
implic (Simple _  ) = mempty
implic (E vars q c) = [(Set.fromList vars, q, c)]
implic (c :^^: d  ) = implic c <> implic d
