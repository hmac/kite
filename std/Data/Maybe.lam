module Data.Maybe

import Lam.Primitive (Bool, True, False)
import Data.Functor (Functor(..))
import Data.Applicative (Applicative)

type Maybe a = Just a | Nothing

mapMaybe : (a -> b) -> Maybe a -> Maybe b
mapMaybe = _ Nothing -> Nothing
           f (Just x) -> Just (f x)

functorMaybe : Functor Maybe
functorMaybe = Functor { map = mapMaybe }

apMaybe : Maybe (a -> b) -> Maybe a -> Maybe b
apMaybe = Nothing _ -> Nothing
          (Just f) m -> mapMaybe f m

applicativeMaybe : Applicative Maybe
applicativeMaybe = Applicative { functor = functorMaybe, pure = Just, ap = apMaybe }

maybe : b -> (a -> b) -> Maybe a -> b
maybe = n _ Nothing  -> n
        _ f (Just x) -> f x

isJust : Maybe a -> Bool
isJust = Nothing -> False
         _       -> True

isNothing : Maybe a -> Bool
isNothing = Nothing -> True
            _       -> False

fromMaybe : a -> Maybe a -> a
fromMaybe = d Nothing  -> d
            d (Just x) -> x

catMaybes : [Maybe a] -> [a]
catMaybes = []                 -> []
            ((Just x) :: rest) -> x :: (catMaybes rest)
            (Nothing :: rest)  -> catMaybes rest

---- Haskell calls this mapMaybe, but that's the name of our 'fmap' instance
filterMaybe : (a -> Maybe b) -> [a] -> [b]
filterMaybe = _ []        -> []
filterMaybe = f (x :: xs) -> case f x of
                               Just r  -> r :: (filterMaybe f xs)
                               Nothing -> filterMaybe f xs
