module Data.Maybe

import Data.Functor (Functor(..))
import Data.Applicative (Applicative)
import Lam.Bool (Bool(..))

type Maybe a = Just a | Nothing

mapMaybe : (a -> b) -> Maybe a -> Maybe b
mapMaybe _ Nothing = Nothing
mapMaybe f (Just x) = Just (f x)

functorMaybe : Functor Maybe
functorMaybe = Functor { map = mapMaybe }

apMaybe : Maybe (a -> b) -> Maybe a -> Maybe b
apMaybe Nothing _ = Nothing
apMaybe (Just f) m = mapMaybe f m

applicativeMaybe : Applicative Maybe
applicativeMaybe = Applicative { functor = functorMaybe, pure = Just, ap = apMaybe }

maybe : b -> (a -> b) -> Maybe a -> b
maybe n _ Nothing = n
maybe _ f (Just x) = f x

isJust : Maybe a -> Bool
isJust Nothing = False
isJust _ = True

isNothing : Maybe a -> Bool
isNothing Nothing = True
isNothing _ = False

fromMaybe : a -> Maybe a -> a
fromMaybe d Nothing = d
fromMaybe d (Just x) = x

catMaybes : [Maybe a] -> [a]
catMaybes [] = []
catMaybes ((Just x) :: rest) = x :: (catMaybes rest)
catMaybes (Nothing :: rest) = catMaybes rest

-- Haskell calls this mapMaybe, but that's the name of our 'fmap' instance
filterMaybe : (a -> Maybe b) -> [a] -> [b]
filterMaybe _ [] = []
filterMaybe f (x :: xs) = case f x of
                            Just r -> r :: (filterMaybe f xs)
                            Nothing -> filterMaybe f xs
